1. 每个类对象都包含自己的数据成员变量值，成员函数的实现被所有类实例共享(可以联想到类成员函数的函数指针，不需要对每个类实例制定函数指针，只需要对成员函数使用)
2. 指针使用nullptr，访问会提示内存访问错误，而不会造成不可预测的结果。
3. 如果类中**分配了动态内存**，那么通常需要自己实现**析构函数、复制构造函数、复制赋值函数、移动构造函数、移动赋值函数**。称为**5规则**。现代c++应当尽可能避免使用旧式的、动态的内存分配，这样上面5个函数都不需要自己实现，称之为**0规则**，尽可能使用0规则。
4. **建议所有的数据成员都声明为私有的，通过get\set方法进行访问**
5. 友元**违反了封装原则**，不建议使用



### 继承：

1. 派生类创建时顺序是：a.执行基类的构造函数；b.按照数据成员的声明顺序创建数据成员；c.执行派生类的构造函数。也就是说，创建派生类时，**若是基类没有默认的构造函数，派生类的构造函数必须在初始化列表中显式的调用父类的构造函数。**即父类的构造函数一定会被先执行
2. **派生类**不能调用父类private的函数，但是**可以重写父类private的函数**。（Java和C#不可以）
3. 尽可能的**不要在虚函数中使用默认参数**。详见： [05继承08基类方法重载19.12.13.md](05继承08基类方法重载19.12.13.md) 

4. **非pubic继承**：
   1. 没有使用限定符时，**`class`默认为`private`继承**(class Son:Father)；`struct`默认为`public`继承(srtuct Son:Father)
   2. 继承时基类使用protected(private)修饰，则基类的public（public/protected）方法和数据成员在派生类中都是protected(private)。**实际上是进行了降级**。